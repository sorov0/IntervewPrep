A master-level guide on how to think about any LLD question, how to choose classes, decide attributes,
design methods, and build clean, extensible, SOLID LLDs â€” the same way we built Parking Lot,
 BookMyShow, and Hotel Booking System.

Everything is broken down into thumb rules, intuitions, patterns, and repeatable steps.

â­ 1. FIRST PRINCIPLE â€” â€œTHINK IN NOUNS FIRST, VERBS LATERâ€

When you read the requirement:

ğŸ‘‰ Extract NOUNS â†’ classes

Examples:
Parking Lot â†’ Vehicle, ParkingSlot, Ticket, ParkingLot
BookMyShow â†’ Movie, Cinema, City, Show
Hotel Booking â†’ City, Hotel, RoomType, PhysicalRoom, Booking

ğŸ‘‰ Extract VERBS â†’ methods

Examples:

bookTicket(), cancelBooking()

parkVehicle(), unparkVehicle()

searchRooms(), lockRoom()

This is always Step 1.

â­ 2. THINK LIKE A REAL WORLD SYSTEM â†’ â€œMirror the domainâ€

Intuition:

If it exists physically â†’ class
If it exists conceptually â†’ class
If it changes â†’ put logic into a manager/service


Examples:

Parking Slot exists physically â†’ class

Room Variant exists conceptually â†’ class

Booking logic changes â†’ BookingManager (NOT inside Booking)

Payment logic changes â†’ PaymentService (NOT inside Payment)

Why? SRP + extensibility.

â­ 3. THE GOLDEN TRIAD (always design these 3 sets of classes)**
(A) Entities (Models) â†’ Only DATA

No business logic

Only fields & constructors

Like we did in Part 1 of every design

Examples:
Hotel, PhysicalRoom, RoomVariant, Booking, Payment

(B) Managers / Services â†’ All LOGIC

These correspond to real-world behavior.

BookingManager

PaymentService

InventoryService

CheckInManager

ParkingLotManager

ShowManager

They take entities and perform operations.

Thumb Rule:

"If it does work â†’ service.
If it stores state â†’ entity."

(C) Helpers / Patterns â†’ Strategy, Factory, Singleton

Used when changeability is expected.

Examples:

PricingStrategy â†’ Strategy Pattern

PaymentGateway â†’ Strategy

PaymentGatewayFactory â†’ Factory

RoomLockManager â†’ Singleton

â­ 4. DONâ€™T PUT LOGIC INSIDE ENTITIES

This is the most common beginner mistake.

âŒ Booking.confirm()
âœ” BookingManager.confirmBooking()

âŒ Room.isAvailable()
âœ” InventoryService.checkAvailability()

Why?

Entities = stable

Services = flexible

Always follows SRP + OCP

â­ 5. ALWAYS IDENTIFY â€œHIGH-VARIATIONâ€ POINTS â†’ use Strategy

Where logic will change often?

Pricing rules â†’ Strategy

Payment gateways â†’ Strategy

Seat allocation rules â†’ Strategy

Sorting & filtering â†’ Strategy

LLD interviewers LOVE this.

â­ 6. USE FACTORY WHEN CLIENT SHOULDNâ€™T KNOW IMPLEMENTATION

Examples:

PaymentGatewayFactory.getGateway(PaymentMode mode)
PricingStrategyFactory.getStrategy(hotel)


This removes switch-case from business logic.

â­ 7. USE SINGLETON FOR GLOBAL STATES

Examples:

ParkingLot instance

SeatLockManager / RoomLockManager

DataStore for in-memory data (like BMS)

Rules for Singleton:

Global

Shared

One per system

Needs centralized synchronization

â­ 8. THINK IN TERMS OF SYSTEM FLOWS (ALWAYS WRITE THE FLOW FIRST)

Always write:

Search flow

Booking flow

Payment flow

Check-in flow

Cancel/Refund flow

Then derive classes & methods directly.

â­ 9. DECIDE ATTRIBUTES BASED ON â€œWHAT THE OBJECT MUST KNOWâ€

Use the 3-question rule:

Q1: What identity must it store?

id, name, type, cityId, hotelId

Q2: What state must it track?

Booking status

RoomStatus

PaymentStatus

Booked date slots

Q3: What relationships must it hold?

Hotel has rooms

Room has variants

Booking has BookingRooms

City has Hotels

ParkingLot has Floors

If it needs to own something â†’ collection
If it needs to reference something â†’ id

â­ 10. METHODS MUST BE VERBS + ACTIONABLE

Examples:

createBooking()
cancelBooking()
confirmBooking()
searchRooms()
lockRoom()
makePayment()
checkIn()
checkOut()


Not:

âŒ bookingCreation()
âŒ roomHelper()

â­ 11. THINK ABOUT CONCURRENCY EARLY

Every booking system needs:

Lock manager

Atomic operations

Prevent double-booking

Strategies:

Singleton locking

synchronized blocks

Lock room BEFORE confirming booking

Release lock on cancel

This is universally expected in LLD interviews.

â­ 12. ALWAYS ADD EVENT HANDLING IF NOTIFICATIONS EXIST

Use Observer Pattern.

BookingConfirmedEvent

PaymentSuccessEvent

CheckInEvent

Listeners:

EmailNotificationService

SMSNotificationService

â­ 13. ALWAYS WRITE A SIMPLE RUNNER / MAIN CLASS

This proves your system is usable.

Like the Runner in:

Parking Lot

BookMyShow

HotelBooking

Interviewer loves that.

â­ 14. DESIGN FOR EXTENSIBILITY, NOT FEATURES

Ask:

â€œIf tomorrow I add new X, will I break existing code?â€

New RoomType â†’ should NOT break anything

New PaymentMode â†’ just add new gateway class

New PricingRule â†’ add a new strategy

New Notification â†’ add a subscriber

This is the core of OCP (Open Closed Principle).

â­ 15. ALWAYS THINK IN LAYERS

Your LLD should conceptually have:

Models â†’ Services â†’ Helpers â†’ Main Runner


This matches real world:

Entities â†’ Business Logic â†’ Infrastructure â†’ API Layer

â­ 16. FOLLOW THE â€œRULE OF 3â€ WHEN CHOOSING PATTERNS

Use Strategy/Factory/Observer ONLY IF:

You see 3 or more variations OR

You anticipate future changes

Example:

1 payment method? No strategy

3+ payment methods? YES strategy

â­ 17. PREDICT INTERVIEWER FOLLOW-UP QUESTIONS

Every LLD interview ends with:

"How do you scale search?â€

"How do you handle concurrency?â€

"How do you make it extensible?â€

"How do you integrate payment?â€

"How do you design notifications?â€

Design your LLD so you already have answers baked in.

â­ 18. KEEP CLASS COUNT BETWEEN 10â€“25

More = over-engineered
Less = under-designed

Parking Lot: ~12 classes
BookMyShow: ~20 classes
Hotel Booking: ~30 classes

This is the sweet spot.

â­ 19. NEVER MIX CONTROLLERS / SERVICES / MODELS IN LLD

LLD interview â‰  real project
They want the core domain, not API.

â­ 20. ALWAYS EXPLAIN WHY

LLD interview is 50% design, 50% justification.

Explain:

Why you created a class

Why this attribute lives here

Why logic is in a service

Why you used Strategy

Why room-lock needed a Singleton

Why concurrency matters

The â€œwhyâ€ is more important than the classes themselves.

ğŸ¯ FINAL 10-LINE SUMMARY (Print this before any LLD interview)

1ï¸âƒ£ Extract nouns â†’ classes
2ï¸âƒ£ Extract verbs â†’ methods
3ï¸âƒ£ Entities hold data, services hold logic
4ï¸âƒ£ Use Strategy/Factory for changeable components
5ï¸âƒ£ Use Singleton for global shared states
6ï¸âƒ£ Never put business logic inside entities
7ï¸âƒ£ Design flows first â†’ classes after
8ï¸âƒ£ Always handle concurrency
9ï¸âƒ£ Always design for extensibility
ğŸ”Ÿ Build a simple Runner to demonstrate the whole flow


=========================================================================================================================



ğŸ§  FULL 1-PAGE LLD CHEAT SHEET (PRINT THIS BEFORE INTERVIEW)
â­ 1. The Golden Rule:
"Identify NOUNS â†’ classes, VERBS â†’ methods."
â­ 2. Class Identification Framework

Every LLD has exactly these 4 categories of classes:

A) Entities (Data classes â€“ NO logic)

Hotel

Room

Booking

Ticket

Vehicle

Store only state: ID, name, relationships, attributes.

B) Managers / Services (Business Logic)

BookingManager

ParkingLotManager

InventoryService

PaymentService

All behaviors go here.

C) Helper Components (Patterns)

Use when behavior changes:

PricingStrategy (Strategy)

PaymentGateway (Strategy)

GatewayFactory (Factory)

LockManager (Singleton)

EventBus (Observer)

D) Data Container

DataStore (like BMSDatabase or in-memory map)

Holds collections of all entities

â­ 3. Attribute Identification Rules

For each class, ask:

âœ” Identity â†’ What uniquely identifies it?
id, name, typeId, roomId, movieId

âœ” State â†’ What changes over time?
status, bookedSlots, availability, rating

âœ” Relationships â†’ What does it â€œownâ€?
Hotel â†’ Rooms
City â†’ Hotels
Booking â†’ BookingRooms

âœ” Metadata â†’ What does it need to display?
price, duration, rating

â­ 4. Method Identification Rules
Should be:

A verb

Belong to a manager/service (NOT entity)

Examples:

searchRooms()
createBooking()
confirmBooking()
makePayment()
assignSlot()
lockRoom()

â­ 5. ALWAYS Address These 5 Areas (Interview gold)

Search/Query design

State transitions (pending â†’ confirmed â†’ completed)

Concurrency control

Extensibility (Strategy, Factory)

Notifications (Observer)

â­ 6. 6 Must-Use Design Patterns in LLD

Singleton â†’ LockManager, ParkingLot

Strategy â†’ Pricing, Payment

Factory â†’ PaymentGatewayFactory

Observer â†’ Notifications

Builder â†’ Optional for complex objects

Template Method â†’ Optional for workflows

â­ 7. Concurrency Guidelines

Lock the resource before creating booking

Unlock only on cancel/failure

Use synchronized / mutex in LLD

Demonstrate parallel booking scenario

â­ 8. Extensibility / Future-Proofing

Ask yourself:

â€œIf tomorrow a new feature comes, where would I add it?â€

If answer is: â€œModify old classesâ€ â†’ bad LLD
If answer is: â€œAdd new class implementing an interfaceâ€ â†’ great LLD

â­ 9. Architecture Skeleton You Must Always Use
+----------------------+        +----------------------+
|      Entities        | -----> |     DataStore        |
+----------------------+        +----------------------+
|  Pure data classes   |        | Global Singleton     |
+----------------------+        +----------------------+

+----------------------+        +----------------------+
|  Services/Managers   | <----> |  Helper Components   |
+----------------------+        +----------------------+
|  All business logic  |        | Strategy/Factory/etc |
+----------------------+        +----------------------+

â­ 10. Runner Class

Always write a simple runner demonstrating:

Create data

Search

Book

Pay

Confirm

Check-in

Check-out

This proves your LLD is usable.

ğŸ§  END OF 1-PAGE LLD CHEAT SHEET
ğŸ§© 3-STEP LLD BRAINSTORMING FRAMEWORK

Use this whenever interviewer gives ANY LLD problem.

STEP 1 â€” Extract Domain Concepts

Ask yourself:

âœ” What real-world objects exist? (Nouns â†’ Entities)
âœ” What actions exist? (Verbs â†’ Methods)
âœ” What are relationships between entities?
âœ” What lifecycle/states exist?

Example:
Hotel Booking â†’ City, Hotel, RoomType, PhysicalRoom, Booking, Payment

STEP 2 â€” Organize into 4 Layers

Always:

Layer 1 â†’ Entities
Layer 2 â†’ DataStore
Layer 3 â†’ Services
Layer 4 â†’ Helpers (Strategy/Factory/Lock/Observer)

This structure ALWAYS works.

STEP 3 â€” Think about Flows & Constraints

For each feature:

âœ” Search flow
âœ” Booking flow
âœ” Payment flow
âœ” Notification flow
âœ” Cancellation flow

Then apply:

Concurrency

Validation

Exceptions

Extensibility

This guarantees completeness.

ğŸ”¥ SUPERPOWER TIP:

â€œIf you can design one booking system well, you can design all LLD systems.â€
ParkingLot, BMS, HotelBooking are identical patterns.

ğŸš€ Template to design ANY LLD in 5 minutes

Use this template in your head or write it on paper:

1. Identify Entities
Class A
  - attributes
Class B
  - attributes
Class C
  - attributes

2. Identify Managers/Services
ManagerA
  methods â†’ (action verbs)
ManagerB
  methods

3. Add Patterns for Extensibility

Choose based on volatility:

Strategy:
    Interface XStrategy
    Impl StrategyA
    Impl StrategyB

Factory:
    Class XFactory.get(type)

Singleton:
    LockManager
    DataStore

Observer:
    EventBus

4. Model State Transitions
enum Status { â€¦ }

5. Model Relationships
A has list of B
B refers to A via id

6. Handle Concurrency
LockManager.lock()
LockManager.unlock()

7. Write 5-key Flows
search()
book()
pay()
confirm()
cancel()

8. Write a Runner (Main Class)

Demonstrate the flow.

ğŸ¯ You're now officially LLD-ready for ANY interview.